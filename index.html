<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Witch's Tears - Animation Fix</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; padding: 0; background-color: #111; color: #fff; font-family: 'Press Start 2P', cursive; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; overflow: hidden; }
        #game-container { position: relative; box-shadow: 0 0 30px rgba(0,0,0,0.8); border: 4px solid #555; display: flex; flex-direction: column; background-color: #000; width: 800px; }
        #canvas-wrapper { position: relative; width: 800px; height: 450px; }
        canvas { background-color: #2b3a42; display: block; image-rendering: pixelated; }
        #ui-layer { position: relative; width: 100%; background: #222; padding: 20px; box-sizing: border-box; border-top: 4px solid #fff; min-height: 100px; font-family: 'Press Start 2P', cursive; display: flex; align-items: center; justify-content: center; }
        #narrator-text { color: #ddd; font-size: 10px; line-height: 18px; text-align: center; width: 100%; }
        #start-screen, #game-over-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 10; backdrop-filter: blur(5px); text-align: center; padding: 20px;}
        #game-over-screen { display: none; background: rgba(50, 0, 0, 0.85); }
        .hud-btn { position: absolute; top: 10px; background: rgba(0,0,0,0.5); border: 2px solid #fff; color: #fff; font-family: 'Press Start 2P', cursive; font-size: 10px; padding: 8px 12px; cursor: pointer; z-index: 20; display: none; }
        .hud-btn:hover { background: #ffcc00; color: #000; }
        #menu-btn { right: 10px; } #log-btn { right: 90px; } 
        h1 { margin: 0 0 60px 0; color: #aaddff; text-shadow: 4px 4px #000; font-size: 32px; line-height: 1.5; }
        button.main-btn { background: #ffcc00; border: 2px solid #fff; padding: 15px 30px; font-family: 'Press Start 2P', cursive; font-size: 14px; cursor: pointer; box-shadow: 4px 4px #000; color: #333; transition: transform 0.1s; }
        button.main-btn:hover { transform: scale(1.05); background: #ffdb4d; }
        button.main-btn:active { transform: translateY(4px); box-shadow: 0 0 #000; }
    </style>
</head>
<body>

<div id="game-container">
    <div id="canvas-wrapper">
        <canvas id="gameCanvas" width="800" height="450"></canvas>
        <button id="log-btn" class="hud-btn">LOG</button>
        <button id="menu-btn" class="hud-btn">MENU</button>
        <div id="start-screen">
            <h1>THE WITCH'S<br>TEARS</h1>
            <button id="start-btn" class="main-btn">BEGIN JOURNEY</button>
        </div>
        <div id="game-over-screen">
            <h2 id="death-reason" style="color:#ff4444; margin-bottom:30px; text-align:center; line-height:1.5; font-size: 14px;">GAME OVER</h2>
            <button id="restart-level-btn" class="main-btn">TRY AGAIN</button>
        </div>
    </div>
    <div id="ui-layer">
        <div id="narrator-text">...</div>
    </div>
</div>

<script>
// ==========================================
// ğŸ”Š éŸ³æ•ˆå¼•æ“ï¼šåˆ©ç”¨ Web Audio API ç”Ÿæˆ 8-bit å¾©å¤éŸ³æ•ˆ
// ==========================================
const AudioCtx = window.AudioContext || window.webkitAudioContext;
const audioCtx = new AudioCtx();

/**
 * æ’­æ”¾æŒ‡å®šé¡å‹çš„åˆæˆéŸ³æ•ˆ
 * @param {string} type - éŸ³æ•ˆé¡å‹
 */
function playSound(type) {
    // ç€è¦½å™¨å®‰å…¨ç­–ç•¥ï¼šè‹¥æ²’æœ‰ä½¿ç”¨è€…äº’å‹• (é»æ“Šç­‰)ï¼ŒAudioContext æœƒè™•æ–¼ suspended ç‹€æ…‹ã€‚é€™è£¡åšä¸€å±¤é˜²è­·ã€‚
    if (audioCtx.state === 'suspended') return;

    // å‰µå»ºæŒ¯ç›ªå™¨ (ç”¢ç”Ÿæ³¢å½¢è²éŸ³) èˆ‡éŸ³é‡æ§åˆ¶å™¨ (Gain)
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();

    // å°‡æŒ¯ç›ªå™¨é€£æ¥è‡³éŸ³é‡æ§åˆ¶å™¨ï¼Œå†é€£æ¥è‡³ç³»çµ±éŸ³éŸ¿è¼¸å‡º
    osc.connect(gain);
    gain.connect(audioCtx.destination);

    const now = audioCtx.currentTime;

    switch(type) {
        case 'jump':
            // è·³èºéŸ³æ•ˆï¼šä½¿ç”¨æ–¹æ³¢ (Square wave)ï¼Œé »ç‡å¿«é€Ÿä¸Šå‡è£½é€ ã€Œå’»ã€çš„æ„Ÿè¦º
            osc.type = 'square';
            osc.frequency.setValueAtTime(150, now); // èµ·å§‹ä½é » 150Hz
            osc.frequency.exponentialRampToValueAtTime(400, now + 0.1); // 0.1ç§’å…§æŒ‡æ•¸ä¸Šå‡è‡³ 400Hz
            gain.gain.setValueAtTime(0.1, now); // åˆå§‹éŸ³é‡ 0.1
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1); // éŸ³é‡å¹³æ»‘è¡°æ¸›ï¼Œé¿å…ç ´éŸ³
            osc.start(now);
            osc.stop(now + 0.1); // 0.1ç§’å¾Œåœæ­¢
            break;

        case 'pickup':
            // ç²å¾—é“å…·ï¼šä½¿ç”¨æ­£å¼¦æ³¢ (Sine wave)ï¼Œç™¼å‡ºå…©å€‹æ¸…è„†çš„ã€Œå®å’šã€é«˜éŸ³
            osc.type = 'sine';
            osc.frequency.setValueAtTime(600, now); // ç¬¬ä¸€å€‹éŸ³ 600Hz
            osc.frequency.setValueAtTime(800, now + 0.1); // 0.1ç§’æ™‚ç¬é–“åˆ‡æ›ç‚º 800Hz
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3); // è²éŸ³æŒçºŒ 0.3 ç§’ç·©æ…¢è¡°æ¸›
            osc.start(now);
            osc.stop(now + 0.3);
            break;

        case 'hit':
            // å—å‚·éŸ³æ•ˆï¼šä½¿ç”¨é‹¸é½’æ³¢ (Sawtooth wave)ï¼Œå¸¶æœ‰ç²—ç³™ã€é›»æ“Šæ„Ÿçš„é›œè¨ŠéŸ³
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(150, now); 
            osc.frequency.linearRampToValueAtTime(50, now + 0.2); // é »ç‡ç·šæ€§ä¸‹é™è£½é€ ã€Œæ‰è½æ„Ÿã€
            gain.gain.setValueAtTime(0.2, now); // éŸ³é‡ç¨å¾®å¤§ä¸€é»
            gain.gain.linearRampToValueAtTime(0.01, now + 0.2);
            osc.start(now);
            osc.stop(now + 0.2);
            break;

        case 'door':
            // ğŸ”Š å‚³é€é–€éŸ³æ•ˆæ›´æ–°ï¼šé »ç‡å¿«é€Ÿä¸Šå‡çš„é­”æ³• Warp è²éŸ³ (Sine Wave)
            osc.type = 'sine';
            osc.frequency.setValueAtTime(200, now);
            osc.frequency.exponentialRampToValueAtTime(800, now + 0.5); // é »ç‡å¾ 200 é£†å‡åˆ° 800
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.5);
            osc.start(now);
            osc.stop(now + 0.5);
            break;

        case 'gameover':
            // éŠæˆ²çµæŸéŸ³æ•ˆï¼šæ²‰é‡ä¸”ç·©æ…¢é™ä½çš„é‹¸é½’æ³¢ï¼Œç‡Ÿé€ å¤±æ•—æ„Ÿ
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(200, now);
            osc.frequency.exponentialRampToValueAtTime(40, now + 0.8);
            gain.gain.setValueAtTime(0.2, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.8);
            osc.start(now);
            osc.stop(now + 0.8);
            break;

        case 'win':
            // å‹åˆ©éŸ³æ•ˆï¼šæ¨¡æ“¬ç¶“å…¸ 8-bit çš„ç¶éŸ³ (Arpeggio) å‡éšå’Œå¼¦
            const freqs = [440, 554, 659, 880]; // A4, C#5, E5, A5
            freqs.forEach((freq, index) => {
                const o = audioCtx.createOscillator();
                const g = audioCtx.createGain();
                o.type = 'square';
                o.connect(g);
                g.connect(audioCtx.destination);
                o.frequency.setValueAtTime(freq, now + index * 0.1); // æ¯å€‹éŸ³ç¬¦å»¶é² 0.1 ç§’ä¾æ¬¡æ’­æ”¾
                g.gain.setValueAtTime(0.1, now + index * 0.1);
                g.gain.exponentialRampToValueAtTime(0.01, now + index * 0.1 + 0.2); // æ¯å€‹éŸ³ç¬¦æŒçºŒ 0.2 ç§’
                o.start(now + index * 0.1);
                o.stop(now + index * 0.1 + 0.2);
            });
            break;

        case 'select':
            // ä»‹é¢é¸æ“‡éŸ³æ•ˆï¼šæ¥µçŸ­ä¿ƒçš„ã€Œå—¶ã€è²
            osc.type = 'sine';
            osc.frequency.setValueAtTime(800, now);
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
            osc.start(now);
            osc.stop(now + 0.1);
            break;

        case 'chestOpen':
            // ğŸ”Š å¯¶ç®±é–‹å•ŸéŸ³æ•ˆï¼šé­”æ³•é–ƒçˆèˆ¬çš„ä¸Šå‡ç¶éŸ³
            [440, 554, 659, 880, 1108].forEach((f, i) => {
                const o = audioCtx.createOscillator();
                const g = audioCtx.createGain();
                o.type = 'sine'; o.connect(g); g.connect(audioCtx.destination);
                o.frequency.setValueAtTime(f, now + i * 0.05);
                g.gain.setValueAtTime(0.1, now + i * 0.05);
                g.gain.exponentialRampToValueAtTime(0.01, now + i * 0.05 + 0.3);
                o.start(now + i * 0.05); o.stop(now + i * 0.05 + 0.3);
            });
            break;

        case 'mushroomBounce':
            // ğŸ”Š è˜‘è‡å½ˆè·³éŸ³æ•ˆï¼šQå½ˆçš„æ»‘éŸ³
            osc.type = 'sine';
            osc.frequency.setValueAtTime(300, now);
            osc.frequency.exponentialRampToValueAtTime(900, now + 0.2); // é »ç‡è¿…é€Ÿæ‹”é«˜
            gain.gain.setValueAtTime(0.2, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
            osc.start(now);
            osc.stop(now + 0.2);
            break;

        case 'meow_white':
            // ğŸ”Š ç™½è²“å«è²ï¼šè¼•æŸ”é«˜éŸ³
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(800, now);
            osc.frequency.exponentialRampToValueAtTime(600, now + 0.3);
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
            osc.start(now); osc.stop(now + 0.3);
            break;

        case 'meow_black':
            // ğŸ”Š é»‘è²“å«è²ï¼šä½æ²‰å¸¶é»æ²™å•ï¼ˆæ–¹æ³¢ï¼‰
            osc.type = 'square';
            osc.frequency.setValueAtTime(300, now);
            osc.frequency.linearRampToValueAtTime(150, now + 0.4);
            gain.gain.setValueAtTime(0.05, now);
            gain.gain.linearRampToValueAtTime(0.01, now + 0.4);
            osc.start(now); osc.stop(now + 0.4);
            break;

        case 'meow_orange':
            // ğŸ”Š æ©˜è²“å«è²ï¼šé©šåš‡çŸ­ä¿ƒ
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(500, now);
            osc.frequency.exponentialRampToValueAtTime(900, now + 0.2);
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
            osc.start(now); osc.stop(now + 0.2);
            break;
    }
}

// ğŸ”Š BGM å¼•æ“ï¼šå¤šå ´æ™¯ç¨ç«‹éŸ³æ¨‚ç³»çµ±
let bgmPlaying = false;
let nextNoteTime = 0;
let currentNote = 0;
let bgmTimerID;

// ğŸ”Š ç‚º 5 å€‹ä¸åŒå ´æ™¯è¨­å®šä¸åŒçš„éŸ³æ¨‚è»Œé“ (é¿å…å–®èª¿)
const bgmTracks = {
    1: { notes: [329.63, 392.00, 440.00, 493.88, 392.00, 440.00], tempo: 140, type: 'sine' },      // æ£®æ—ï¼šç©ºéˆå­¤ç¨çš„é›¨æ»´æ„Ÿ
    2: { notes: [261.63, 311.13, 392.00, 311.13, 261.63, 196.00], tempo: 120, type: 'triangle' },  // æœ¨å±‹å‰ï¼šå¾®å¼±ç¥ç§˜çš„æ„Ÿè¦º
    3: { notes: [146.83, 164.81, 174.61, 164.81], tempo: 220, type: 'square' },                    // é»‘è²“èµ°å»Šï¼šç·Šå¼µã€ä½æ²‰æ€¥ä¿ƒ
    4: { notes: [392.00, 329.63, 261.63, 329.63], tempo: 160, type: 'sine' },                      // æ©˜è²“è‡¥å®¤ï¼šç¨å¾®æ´»æ½‘ã€è·³èº
    5: { notes: [440.00, 349.23, 329.63, 293.66, 329.63, 440.00], tempo: 90, type: 'triangle' }    // å¥³å·«æˆ¿é–“ï¼šæ‚²å‚·ã€ç·©æ…¢ä¸‹è¡Œ
};

function scheduleNote(beatNumber, time) {
    const track = bgmTracks[currentLevel] || bgmTracks[1]; // æ ¹æ“šç•¶å‰é—œå¡ç²å–å°æ‡‰éŸ³æ¨‚
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = track.type; // ğŸ”Š æ ¹æ“šé—œå¡æ›´æ›æ¨‚å™¨éŸ³è‰²
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.frequency.value = track.notes[beatNumber];
    
    // éŸ³é‡æ§åˆ¶
    gain.gain.setValueAtTime(0, time);
    gain.gain.linearRampToValueAtTime(0.03, time + 0.05); 
    gain.gain.linearRampToValueAtTime(0, time + 0.25);
    
    osc.start(time);
    osc.stop(time + 0.3);
}

function scheduler() {
    const track = bgmTracks[currentLevel] || bgmTracks[1];
    // æå‰æ’ç¨‹ä»¥ç¢ºä¿éŸ³æ¨‚ç„¡ç¸«å¾ªç’°
    while (nextNoteTime < audioCtx.currentTime + 0.1) {
        scheduleNote(currentNote, nextNoteTime);
        nextNoteTime += 60.0 / track.tempo; // ğŸ”Š æ ¹æ“šé—œå¡æ›´æ›é€Ÿåº¦
        currentNote = (currentNote + 1) % track.notes.length;
    }
    bgmTimerID = setTimeout(scheduler, 25);
}

function startBGM() {
    if (bgmPlaying) return;
    bgmPlaying = true;
    if (audioCtx.state === 'suspended') audioCtx.resume();
    nextNoteTime = audioCtx.currentTime + 0.1;
    scheduler();
}

function stopBGM() {
    bgmPlaying = false;
    clearTimeout(bgmTimerID);
}

// ğŸ”Š æ›å ´æ™¯æ™‚æ›´æ–° BGM
function updateBGMForLevel() {
    if(bgmPlaying) {
        stopBGM();
        currentNote = 0; // é‡ç½®éŸ³ç¬¦åˆ°ç¬¬ä¸€æ‹
        startBGM();
    }
}
// ==========================================


const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const narratorEl = document.getElementById('narrator-text');
const startScreen = document.getElementById('start-screen');
const startBtn = document.getElementById('start-btn');
const gameOverScreen = document.getElementById('game-over-screen');
const deathReasonEl = document.getElementById('death-reason');
const restartBtn = document.getElementById('restart-level-btn');
const menuBtn = document.getElementById('menu-btn');
const logBtn = document.getElementById('log-btn');

const GAME_STATE = { MENU: 0, PLAYING: 1, ENDING: 2, GAMEOVER: 3, INVENTORY: 4, GOT_ITEM: 5, ENDING_SEQUENCE: 6, PROLOGUE: 7, HISTORY: 8 };
let currentState = GAME_STATE.MENU;
let currentLevel = 1;
let rainDrops = [];
let particles = []; 
let popupData = { text: "", icon: "", desc: "", img: null }; 
let dialogueHistory = []; 

const camera = { x: 0 };

// è³‡æºå°è±¡
const charImgs = {
    player: new Image(), 
    player_idle1: new Image(), player_idle2: new Image(),
    player_run1: new Image(), player_run2: new Image(),
    player_jump: new Image(),
    player_sheet: new Image(), 
    white_cat: new Image(), black_cat: new Image(), orange_cat: new Image(), witch: new Image(),
    
    // NPC Sheets
    white_cat_sheet: new Image(), 
    black_cat_sheet: new Image(), 
    orange_cat_sheet: new Image(), 
    witch_sheet: new Image() 
};

const itemImgs = { 
    mushroom: new Image(), fruit: new Image(), 
    chest_closed: new Image(), chest_open: new Image(), 
    door_closed: new Image(), door_open: new Image(), 
    door_sheet: new Image(), 
    bucket: new Image(), portal_sheet: new Image() 
};

const iconImgs = { key: new Image(), fish: new Image(), swatter: new Image(), fruit: new Image() };
const platformImgs = { grass: new Image(), wood: new Image() };
const bgImgs = { forest: new Image(), cabin: new Image(), porch: new Image(), bedroom: new Image(), witch_room: new Image(), ending: new Image(), title: new Image() };

// ğŸ”Š çµå±€éŸ³æ¨‚è¨­å®š (å…¨å±€è®Šæ•¸)
// é€™è£¡å¡«å…¥ä½ ä¸Šå‚³çš„éŸ³æ¨‚é€£çµ
const endingMusic = new Audio('https://files.catbox.moe/xgwcj0.mp3'); 
endingMusic.volume = 0.6; // éŸ³é‡èª¿æ•´

// å•Ÿå‹•è·¨åŸŸ
const allImgs = [...Object.values(charImgs), ...Object.values(itemImgs), ...Object.values(bgImgs), ...Object.values(iconImgs), ...Object.values(platformImgs)];
allImgs.forEach(img => img.crossOrigin = "Anonymous");

function loadAssets() {
    // NPC å‹•ç•« Sheet
    charImgs.white_cat_sheet.src  = 'https://i.imgur.com/mSGIEOI.png'; 
    charImgs.black_cat_sheet.src  = 'https://i.imgur.com/3XlImxi.png'; 
    charImgs.orange_cat_sheet.src = 'https://i.imgur.com/VMwStDW.png'; 
    charImgs.witch_sheet.src      = 'https://i.imgur.com/ekI1vIy.png'; 

    // é–€çš„å‹•ç•«
    itemImgs.door_sheet.src   = 'https://i.imgur.com/YB6Wczb.png'; 

    // Kelvin
    charImgs.player.src = 'https://i.imgur.com/RJs7Awx.png'; 
    charImgs.player_idle1.src = 'https://i.imgur.com/RJs7Awx.png'; 
    charImgs.player_idle2.src = 'https://i.imgur.com/Y3hMUTl.png';
    charImgs.player_run1.src  = 'https://i.imgur.com/dmyWpRN.png'; 
    charImgs.player_run2.src  = 'https://i.imgur.com/VeHpPfe.png'; 
    charImgs.player_jump.src  = 'https://i.imgur.com/7PFUcLM.png'; 

    // NPC éœæ…‹å‚™ç”¨
    charImgs.white_cat.src  = 'https://i.imgur.com/mSGIEOI.png'; 
    charImgs.black_cat.src  = 'https://i.imgur.com/3XlImxi.png'; 
    charImgs.orange_cat.src = 'https://i.imgur.com/A8MyV01.png'; 
    charImgs.witch.src      = 'https://i.imgur.com/zZEqoRW.png';

    // é“å…·
    itemImgs.mushroom.src     = 'https://i.imgur.com/Xit3cxC.png'; 
    itemImgs.fruit.src        = 'https://i.imgur.com/BvdRLsX.png';    
    itemImgs.chest_closed.src = 'https://i.imgur.com/paidehq.png'; 
    itemImgs.chest_open.src   = 'https://i.imgur.com/6LjvqNh.png'; 
    itemImgs.bucket.src       = 'https://i.imgur.com/paidehq.png';
    itemImgs.door_closed.src = ''; itemImgs.door_open.src = ''; 
    
    // UI
    iconImgs.key.src     = 'https://i.imgur.com/ztn9EXR.png'; 
    iconImgs.fruit.src   = 'https://i.imgur.com/BvdRLsX.png';
    iconImgs.fish.src    = 'https://i.imgur.com/h5AiyzU.png'; 
    iconImgs.swatter.src = 'https://i.imgur.com/SYGthMd.jpeg'; 

    // å¹³å°
    platformImgs.grass.src = 'https://i.imgur.com/8HIuhKs.png'; 
    platformImgs.wood.src  = 'https://i.imgur.com/9QfdKiD.png';

    // èƒŒæ™¯
    bgImgs.title.src        = 'https://i.imgur.com/JLUth2f.jpeg'; 
    bgImgs.forest.src       = 'https://i.imgur.com/z0vlHqF.jpeg'; 
    bgImgs.cabin.src        = 'https://i.imgur.com/z0vlHqF.jpeg'; 
    bgImgs.porch.src        = 'https://i.imgur.com/GnFq3rV.jpeg'; 
    bgImgs.bedroom.src      = 'https://i.imgur.com/GnFq3rV.jpeg'; 
    bgImgs.witch_room.src   = 'https://i.imgur.com/F2lehBx.jpeg'; 
    bgImgs.ending.src       = 'https://i.imgur.com/3XOytN9.jpeg'; 
}

const player = {
    x: 50, y: 310, 
    width: 100, height: 100, 
    color: '#ff6b6b', customEmoji: '', 
    vx: 0, vy: 0, speed: 5, jumpPower: -12, 
    grounded: false, invisible: false, invisibleTimer: 0, facingRight: true,
    hp: 3, maxHp: 3, iframes: 0, 
    inventory: { hasKey: false, hasFish: false, hasSwatter: false, hasFruit: false, dialogueStage: 0 },
    state: 'idle' 
};

const keys = { left: false, right: false, up: false, interact: false, interactPressed: false, inventory: false, inventoryPressed: false, log: false, logPressed: false };
let levels = {};

function init() {
    loadAssets(); 
    for(let i=0; i<150; i++) rainDrops.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, length: Math.random() * 20 + 10, speed: Math.random() * 5 + 8 });
    setupLevels();
    
    window.addEventListener('keydown', (e) => {
        if(e.key === 'ArrowLeft' || e.key === 'a') keys.left = true;
        if(e.key === 'ArrowRight' || e.key === 'd') keys.right = true;
        if(e.key === 'ArrowUp' || e.key === 'w') keys.up = true;
        if(e.key === 'f' || e.key === 'F') keys.interact = true;
        if(e.key === 'i' || e.key === 'I' || e.key === 'b' || e.key === 'B') keys.inventory = true;
        if(e.key === 'h' || e.key === 'H') keys.log = true;
    });
    window.addEventListener('keyup', (e) => {
        if(e.key === 'ArrowLeft' || e.key === 'a') keys.left = false;
        if(e.key === 'ArrowRight' || e.key === 'd') keys.right = false;
        if(e.key === 'ArrowUp' || e.key === 'w') keys.up = false;
        if(e.key === 'f' || e.key === 'F') { keys.interact = false; keys.interactPressed = false; }
        if(e.key === 'i' || e.key === 'I' || e.key === 'b' || e.key === 'B') { keys.inventory = false; keys.inventoryPressed = false; }
        if(e.key === 'h' || e.key === 'H') { keys.log = false; keys.logPressed = false; }
    });
    
    startBtn.addEventListener('click', () => {
        // ğŸ”Š å–šé†’éŸ³æ•ˆå¼•æ“ï¼šè§£æ±ºç¾ä»£ç€è¦½å™¨é è¨­ç¦æ­¢è‡ªå‹•æ’­æ”¾çš„å•é¡Œ
        if (audioCtx.state === 'suspended') audioCtx.resume();
        playSound('select'); // ğŸ”Š é»æ“Šé–‹å§‹æŒ‰éˆ•éŸ³æ•ˆ
        startBGM(); // ğŸ”Š éŠæˆ²é–‹å§‹ï¼Œé–‹å§‹æ’­æ”¾èƒŒæ™¯éŸ³æ¨‚

        startScreen.style.display = 'none'; 
        menuBtn.style.display = 'block'; 
        logBtn.style.display = 'block'; 
        currentState = GAME_STATE.PROLOGUE;
        player.hp = 3; 
        player.inventory = { hasKey: false, hasFish: false, hasSwatter: false, hasFruit: false, dialogueStage: 0 };
        dialogueHistory = []; 
        writeText("", true);
    });
    
    restartBtn.addEventListener('click', () => {
        playSound('select'); // ğŸ”Š é»æ“ŠéŸ³æ•ˆ
        startBGM(); // ğŸ”Š é‡æ–°é–‹å§‹ï¼Œæ¢å¾©èƒŒæ™¯éŸ³æ¨‚
        endingMusic.pause(); // ğŸ”Š å¦‚æœæ­£åœ¨æ’­çµå±€éŸ³æ¨‚ï¼Œå°‡å…¶æš«åœ
        endingMusic.currentTime = 0; // é‡ç½®éŸ³æ¨‚é€²åº¦
        gameOverScreen.style.display = 'none'; player.hp = 3; player.iframes = 0; currentState = GAME_STATE.PLAYING; resetLevel();
    });
    menuBtn.addEventListener('click', () => {
        playSound('select'); // ğŸ”Š é»æ“ŠéŸ³æ•ˆ
        stopBGM(); // ğŸ”Š å›åˆ°ä¸»é¸å–®ï¼Œåœæ­¢èƒŒæ™¯éŸ³æ¨‚
        endingMusic.pause(); // ğŸ”Š å¦‚æœæ­£åœ¨æ’­çµå±€éŸ³æ¨‚ï¼Œå°‡å…¶æš«åœ
        endingMusic.currentTime = 0; // é‡ç½®éŸ³æ¨‚é€²åº¦
        currentState = GAME_STATE.MENU; startScreen.style.display = 'flex'; gameOverScreen.style.display = 'none'; menuBtn.style.display = 'none'; logBtn.style.display = 'none';
    });
    logBtn.addEventListener('click', () => {
        playSound('select'); // ğŸ”Š é»æ“ŠéŸ³æ•ˆ
        if (currentState === GAME_STATE.PLAYING || currentState === GAME_STATE.INVENTORY) currentState = GAME_STATE.HISTORY;
        else if (currentState === GAME_STATE.HISTORY) currentState = GAME_STATE.PLAYING;
    });

    loop();
}

function showItemPopup(itemName, iconEmoji, desc, iconImg) {
    playSound('pickup'); // ğŸ”Š ç•¶ç²å¾—é“å…·ä¸¦é¡¯ç¤ºå½ˆçª—æ™‚ï¼Œæ’­æ”¾ç²å¾—é“å…·çš„éŸ³æ•ˆ
    popupData.text = itemName; 
    popupData.icon = iconEmoji; 
    popupData.desc = desc; 
    popupData.img = iconImg; 
    currentState = GAME_STATE.GOT_ITEM;
}

function setupLevels() {
    levels = {
        1: { name: "Endless Rain Forest", width: 2000, platforms: [{x: 0, y: 400, w: 2000, h: 60}], items: [{type: 'door', x: 1850, y: 250, w: 90, h: 150, open: true}], npcs: [], indoors: false },
        2: { name: "Cabin Entrance", width: 2000, platforms: [{x: 0, y: 400, w: 2000, h: 60}, {x: 1000, y: 200, w: 120, h: 20}], items: [{type: 'mushroom', x: 1150, y: 370, w: 50, h: 40, collected: false}, {type: 'chest', x: 1040, y: 170, w: 40, h: 40, opened: false}, {type: 'door', x: 1850, y: 250, w: 90, h: 150, open: false}], npcs: [{type: 'white_cat', x: 1750, y: 365, w: 60, h: 45, alert: true, introShown: false}], indoors: false },
        3: { name: "The Hallway (Black Cat)", width: 2000, platforms: [{x: 0, y: 400, w: 2000, h: 60}], items: [{type: 'bucket', x: 400, y: 365, w: 50, h: 50, collected: false}, {type: 'door', x: 1850, y: 250, w: 90, h: 150, open: false}], npcs: [{type: 'black_cat', x: 1000, y: 170, w: 250, h: 250, alert: true, fed: false, introShown: false}], indoors: true, waves: [], waveTimer: 0 },
        4: { name: "Bedroom Corridor (Kai)", width: 2000, platforms: [{x: 0, y: 400, w: 2000, h: 60}], items: [{type: 'door', x: 1850, y: 250, w: 90, h: 150, open: false}], npcs: [{type: 'orange_cat', x: 1000, y: 300, w: 110, h: 110, scared: false, introShown: false}], indoors: true },
        5: { name: "Witch's Room", width: 800, platforms: [{x: 0, y: 400, w: 800, h: 50, water: true}], items: [], npcs: [{type: 'witch', x: 600, y: 270, w: 90, h: 130}], indoors: true }
    };
}

function startLevel(lvl) {
    currentLevel = lvl; player.x = 50; player.y = 300; player.vx = 0; player.vy = 0; camera.x = 0; 
    updateBGMForLevel(); // ğŸ”Š é—œå¡åˆ‡æ›æ™‚ï¼ŒåŒæ­¥åˆ‡æ›å°ˆå±¬ BGM
    
    if(lvl === 1) writeText("Step gently into the rain. [A/D] Move, [W] Jump. The forest breathes.");
    else if(lvl === 2) writeText("Dengdeng, white as a cloud, heavy with silence.\nA glint of hope hangs from her neck.");
    else if(lvl === 3) writeText("A roar of hunger, not hate. His magic ripples through the air.\nHe just needs a little warmth (and fish).");
    else if(lvl === 4) writeText("Kai stands like a fortress.\nBut even mountains tremble at the sound of thunder (Swatter).");
    else if(lvl === 5) { 
        writeText("The room is flooded with tears. The Witch turns her back to the world.\nApproach her."); 
        player.inventory.dialogueStage = 0; 
    }
}

function resetLevel() { setupLevels(); if(currentLevel === 3) player.inventory.hasFish = false; player.invisible = false; startLevel(currentLevel); }
function showGameOver(reason) { 
    playSound('gameover'); // ğŸ”Š è§¸ç™¼ Game Over éŸ³æ•ˆ
    stopBGM(); // ğŸ”Š éŠæˆ²çµæŸï¼Œåœæ­¢èƒŒæ™¯éŸ³æ¨‚
    currentState = GAME_STATE.GAMEOVER; deathReasonEl.innerText = reason; gameOverScreen.style.display = 'flex'; 
}

function update() {
    if (currentState === GAME_STATE.PROLOGUE) {
        if (keys.interact && !keys.interactPressed) {
            keys.interactPressed = true;
            dialogueHistory.push("--- PROLOGUE ---");
            dialogueHistory.push("An eternal rain falls on the forest.");
            dialogueHistory.push("Legends say it is a curse from the Witch.");
            dialogueHistory.push("Kelvin decides to find her and bring back the sun.");
            dialogueHistory.push("----------------");
            currentState = GAME_STATE.PLAYING;
            startLevel(1);
        }
        return;
    }

    if (keys.log && !keys.logPressed) {
        keys.logPressed = true;
        if (currentState === GAME_STATE.PLAYING || currentState === GAME_STATE.INVENTORY) currentState = GAME_STATE.HISTORY;
        else if (currentState === GAME_STATE.HISTORY) currentState = GAME_STATE.PLAYING;
    }

    if (currentState === GAME_STATE.GOT_ITEM) { if (keys.interact && !keys.interactPressed) { keys.interactPressed = true; currentState = GAME_STATE.PLAYING; } return; }
    if (keys.inventory && !keys.inventoryPressed) { keys.inventoryPressed = true; if (currentState === GAME_STATE.PLAYING) currentState = GAME_STATE.INVENTORY; else if (currentState === GAME_STATE.INVENTORY) currentState = GAME_STATE.PLAYING; }
    
    if (currentState === GAME_STATE.ENDING_SEQUENCE) return;

    if(currentState !== GAME_STATE.PLAYING && currentState !== GAME_STATE.ENDING) return;
    
    if (keys.left) { player.vx = -player.speed; player.facingRight = false; player.state = 'run'; } 
    else if (keys.right) { player.vx = player.speed; player.facingRight = true; player.state = 'run'; } 
    else { player.vx = 0; player.state = 'idle'; }
    player.vy += 0.5; player.x += player.vx; player.y += player.vy;
    if (!player.grounded) player.state = 'jump';
    if(player.iframes > 0) player.iframes--;

    let levelData = levels[currentLevel];
    let targetCamX = player.x - canvas.width / 3;
    let maxCamX = (levelData.width || 800) - canvas.width;
    if (maxCamX < 0) maxCamX = 0;
    camera.x = Math.max(0, Math.min(targetCamX, maxCamX));

    if (currentState === GAME_STATE.ENDING && player.y > 300) { player.y = 300; player.vy = 0; player.grounded = true; player.state = 'idle'; }
    else {
        player.grounded = false;
        levelData.platforms.forEach(plat => {
            if (player.x < plat.x + plat.w && player.x + player.width > plat.x && player.y + player.height > plat.y && player.y + player.height < plat.y + plat.h + 20 && player.vy >= 0) {
                player.grounded = true; player.vy = 0; player.y = plat.y - player.height;
            }
        });
    }
    
    // ğŸ”Š åœ¨æ­¤è™•åŠ å…¥è·³èºéŸ³æ•ˆè§¸ç™¼
    if(keys.up && player.grounded) { player.vy = player.jumpPower; player.grounded = false; playSound('jump'); }
    
    let levelWidth = levelData.width || 800;
    if(player.x < 0) player.x = 0; if(player.x > levelWidth - player.width) player.x = levelWidth - player.width; 
    if(player.y > canvas.height) { player.x = 50; player.y = 200; player.vy = 0; camera.x = 0; } 

    if (currentLevel === 1) {
        if (player.x > 300 && player.x < 500 && player.x % 50 < 5) writeText("Press [I] to check your Bag.");
    }

    if(currentState === GAME_STATE.PLAYING) handleLevelLogic(levelData);
    if(player.invisible) { player.invisibleTimer--; if(player.invisibleTimer <= 0) { player.invisible = false; writeText("Effect wore off. Visible again."); } }
    
    if(!levelData.indoors && currentState !== GAME_STATE.ENDING && currentState !== GAME_STATE.ENDING_SEQUENCE) {
        rainDrops.forEach(drop => { drop.y += drop.speed; if (drop.y > canvas.height) { drop.x = Math.random() * canvas.width + camera.x; drop.y = -drop.length; } });
    }
    for(let i=particles.length-1; i>=0; i--) { let p = particles[i]; p.x += p.vx; p.y += p.vy; p.life--; if(p.life <= 0) particles.splice(i, 1); }
}

function handleLevelLogic(data) {
    data.items.forEach(item => {
        if(checkCollision(player, item)) {
            if(item.type === 'mushroom') { 
                // ğŸ”Š ç¢ºä¿åªæœ‰åœ¨å¾€ä¸‹æ‰è½ç¢°åˆ°è˜‘è‡æ™‚æ‰è§¸ç™¼ï¼Œé¿å…å¡ä½ç˜‹ç‹‚æ’­æ”¾
                if (player.vy >= 0) { 
                    player.vy = -20; 
                    playSound('mushroomBounce'); // ğŸ”Š è§¸ç™¼è˜‘è‡å½ˆè·³éŸ³æ•ˆ
                }
            }
            if(item.type === 'chest' && !item.opened && keys.interact && !keys.interactPressed) {
                keys.interactPressed = true; item.opened = true; player.inventory.hasFruit = true; player.invisible = true; player.invisibleTimer = 600;
                playSound('chestOpen'); // ğŸ”Š è§¸ç™¼å¯¶ç®±é–‹å•Ÿé­”æ³•éŸ³æ•ˆ
                showItemPopup("Ghost Fruit", "ğŸ", "Refracts light to walk unseen.", iconImgs.fruit); writeText("Consumed Ghost Fruit! You are fading away...");
            }
            if(item.type === 'bucket' && keys.interact && !keys.interactPressed) {
                keys.interactPressed = true;
                if(!player.inventory.hasFish) { player.inventory.hasFish = true; showItemPopup("Phantom Fish", "ğŸŸ", "A glowing fish from the rain.", iconImgs.fish); writeText("Caught a fish! This should satisfy a giant hunger."); }
            }
            if(item.type === 'door') {
                if(item.open) {
                    // ğŸ”Š é–‹é–€æˆåŠŸéå ´éŸ³æ•ˆ
                    if(keys.interact && !keys.interactPressed) { keys.interactPressed = true; playSound('door'); startLevel(currentLevel + 1); }
                } else {
                    if(keys.interact && !keys.interactPressed) {
                        keys.interactPressed = true;
                        if(currentLevel === 2) {
                            // ğŸ”Š è§£é–æˆåŠŸéŸ³æ•ˆ
                            if(player.inventory.hasKey) { item.open = true; writeText("Door unlocked."); playSound('door'); } 
                            else { writeText("Locked. The white cat guards it."); }
                        } else { writeText("Blocked."); }
                    }
                }
            }
        }
    });

    data.npcs.forEach(npc => {
        let dist = Math.abs(player.x - npc.x);
        if (!npc.introShown && dist < 500) {
            npc.introShown = true;
            if (npc.type === 'white_cat') { writeText("Dengdeng, white as a cloud, heavy with silence.\nA glint of hope hangs from her neck."); playSound('meow_white'); } // ğŸ”Š ç™½è²“åˆæ¬¡è¦‹é¢éŸ³æ•ˆ
            else if (npc.type === 'black_cat') { writeText("A roar of hunger! His magic ripples through the air.\nHe just needs a little warmth (and fish)."); playSound('meow_black'); } // ğŸ”Š é»‘è²“åˆæ¬¡è¦‹é¢éŸ³æ•ˆ
            else if (npc.type === 'orange_cat') { writeText("Kai stands like a fortress.\nBut even mountains tremble at the sound of thunder (Swatter)."); playSound('meow_orange'); } // ğŸ”Š æ©˜è²“åˆæ¬¡è¦‹é¢éŸ³æ•ˆ
        }
        if(npc.type === 'white_cat') {
            if(npc.alert) {
                if(player.invisible) {
                    if(dist < 50 && keys.interact && !keys.interactPressed) {
                        keys.interactPressed = true; player.inventory.hasKey = true; npc.alert = false;
                        playSound('meow_white'); // ğŸ”Š æˆåŠŸæ‹¿åˆ°é‘°åŒ™æ™‚ç™½è²“å–µä¸€è²
                        showItemPopup("Cabin Key", "ğŸ”‘", "A heavy iron key.", iconImgs.key); writeText("Stealth successful. Key taken.");
                    }
                } else {
                    if(dist < 300 && dist > 150) writeText("High above... a Ghost Fruit shimmers."); 
                    if(dist < 150) showGameOver("Dengdeng got startled!\n(You need to be invisible)");
                }
            }
        }
        if(npc.type === 'black_cat' && npc.alert) {
            data.waveTimer++;
            if(data.waveTimer > 150) { data.waveTimer = 0; data.waves.push({x: npc.x, y: npc.y + 220, w: 20, h: 20, speed: 4}); }
            for (let i = data.waves.length - 1; i >= 0; i--) {
                let w = data.waves[i]; w.x -= w.speed;
                if(checkCollision(player, w)) {
                    if(player.iframes <= 0) { 
                        player.hp--; player.iframes = 60; 
                        // ğŸ”Š å—åˆ°é»‘è²“è²æ³¢æ”»æ“Šçš„å—å‚·éŸ³æ•ˆ
                        if(player.hp <= 0) showGameOver("Overwhelmed by the noise..."); else { writeText("Ouch! The scream hurts!"); playSound('hit'); } 
                    }
                }
                if(w.x < camera.x - 100) data.waves.splice(i, 1);
            }
            if(player.x + player.width > npc.x && player.x < npc.x) { player.x = npc.x - player.width; }
            if(dist < 200 && keys.interact && !keys.interactPressed) {
                keys.interactPressed = true;
                if(player.inventory.hasFish) {
                    npc.alert = false; npc.fed = true; data.waves = []; player.inventory.hasFish = false; player.inventory.hasSwatter = true; npc.w = 100; npc.h = 100; npc.y = 300; 
                    playSound('meow_black'); // ğŸ”Š é»‘è²“åƒé£½æ»¿è¶³çš„è²éŸ³
                    data.items.find(i => i.type === 'door').open = true; showItemPopup("Toy Swatter", "ğŸ¸", "Makes thunder sounds.", iconImgs.swatter); writeText("He's full and asleep. Left a toy behind.");
                } else { writeText("HANGRY! Feed him!"); playSound('meow_black'); } // ğŸ”Š æ²’é­šæ™‚æŠ—è­°çš„è²éŸ³
            } 
        }
        if(npc.type === 'orange_cat' && !npc.scared) {
            if(player.x + player.width > npc.x && player.x < npc.x) { player.x = npc.x - player.width; }
            if(dist < 150) {
                if(keys.interact && !keys.interactPressed) {
                    keys.interactPressed = true;
                    if(player.inventory.hasSwatter) {
                        npc.scared = true; npc.x = 2500; data.items.find(i => i.type === 'door').open = true; writeText("ZAP! He thinks it's thunder! He fled!");
                        playSound('meow_orange'); // ğŸ”Š æ©˜è²“è¢«é›»èšŠæ‹åš‡è·‘çš„è²éŸ³
                    } else { writeText("He won't budge. He only fears 'Thunder'..."); playSound('meow_orange'); } // ğŸ”Š æ©˜è²“ä¸å‹•å¦‚å±±çš„è²éŸ³
                }
            }
        }
        if(npc.type === 'witch') {
            if(dist < 120 && keys.interact && !keys.interactPressed) {
                keys.interactPressed = true;
                let stage = player.inventory.dialogueStage;
                if (stage === 0) { writeText("Witch: 'Why are you here? The rain will only drown you.'"); player.inventory.dialogueStage = 1; } 
                else if (stage === 1) { writeText("Kelvin: 'I seek to mend the sky, and heal your sorrow.'"); player.inventory.dialogueStage = 2; } 
                else if (stage === 2) { writeText("Witch: 'My heart is frozen... I am so cold...'"); player.inventory.dialogueStage = 3; } 
                else if (stage === 3) { writeText("[PRESS 'F' TO EMBRACE HER]"); player.inventory.dialogueStage = 4; } 
                else if (stage === 4) { triggerEnding(); }
            }
        }
    });
}

function checkCollision(r1, r2) { return (r1.x < r2.x + r2.w && r1.x + r1.width > r2.x && r1.y < r2.y + r2.h && r1.y + r1.height > r2.y); }

function triggerEnding() { 
    stopBGM(); // ğŸ”Š è§¸ç™¼çµå±€ï¼Œåœæ­¢ä¸€èˆ¬èƒŒæ™¯éŸ³æ¨‚
    
    // ğŸ”Š æ’­æ”¾ä½ çš„å°ˆå±¬çµå±€éŸ³æ¨‚
    endingMusic.currentTime = 0; 
    endingMusic.play().catch(e => console.log("éŸ³æ¨‚æ’­æ”¾å¤±æ•—", e));

    currentState = GAME_STATE.ENDING_SEQUENCE; 
    writeText("You hold her tight. The coldness begins to fade..."); 
    setTimeout(() => { writeText("The tears stop falling. The clouds part for the sun."); setTimeout(() => { currentState = GAME_STATE.ENDING; }, 4000); }, 3000); 
}

function writeText(text, skipLog = false) { 
    narratorEl.innerText = text; 
    if (!skipLog && text && text.trim() !== "" && (dialogueHistory.length === 0 || dialogueHistory[dialogueHistory.length - 1] !== text)) {
        dialogueHistory.push(text);
        if (dialogueHistory.length > 50) dialogueHistory.shift(); 
    }
}
function isImgLoaded(img) { return img && img.src && img.complete && img.naturalWidth !== 0; }

function draw() {
    if (currentState === GAME_STATE.MENU) {
        if (bgImgs.title && isImgLoaded(bgImgs.title)) ctx.drawImage(bgImgs.title, 0, 0, canvas.width, canvas.height);
        else { let grad = ctx.createLinearGradient(0, 0, 0, canvas.height); grad.addColorStop(0, '#1a0b2e'); grad.addColorStop(1, '#4a148c'); ctx.fillStyle = grad; ctx.fillRect(0, 0, canvas.width, canvas.height); }
        
        ctx.strokeStyle = 'rgba(174, 194, 224, 0.4)'; ctx.lineWidth = 1; ctx.beginPath();
        rainDrops.forEach(drop => { ctx.moveTo(drop.x, drop.y); ctx.lineTo(drop.x, drop.y + drop.length); }); ctx.stroke();
        return; 
    }
    
    if (currentState === GAME_STATE.PROLOGUE) {
        ctx.fillStyle = "#000"; ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.strokeStyle = 'rgba(174, 194, 224, 0.4)'; ctx.lineWidth = 1; ctx.beginPath();
        rainDrops.forEach(drop => { ctx.moveTo(drop.x, drop.y); ctx.lineTo(drop.x, drop.y + drop.length); }); ctx.stroke();
        
        ctx.fillStyle = "#fff"; ctx.font = '14px "Press Start 2P"'; ctx.textAlign = "center";
        let lines = [ "An eternal rain falls on the forest.", "Legends say it is a curse from the Witch.", "Kelvin decides to find her", "and bring back the sun.", "", "", "[ PRESS 'F' TO START ]" ];
        let startY = 150; for(let i=0; i<lines.length; i++) { ctx.fillStyle = (i === lines.length - 1) ? "#ffcc00" : "#ddd"; ctx.fillText(lines[i], canvas.width/2, startY + i * 30); }
        return;
    }

    if(currentState === GAME_STATE.ENDING) { drawEnding(); return; }
    
    let levelData = levels[currentLevel];
    let bgDrawn = false; let bgImg = null;
    if (currentLevel === 1) bgImg = bgImgs.forest; else if (currentLevel === 2) bgImg = bgImgs.cabin; else if (currentLevel === 3) bgImg = bgImgs.porch; else if (currentLevel === 4) bgImg = bgImgs.bedroom; else if (currentLevel === 5) bgImg = bgImgs.witch_room;

    if (bgImg && isImgLoaded(bgImg)) {
        if (levelData.width > canvas.width) {
            let parallaxSpeed = 0.5; let bgX = -(camera.x * parallaxSpeed) % canvas.width;
            ctx.drawImage(bgImg, bgX, 0, canvas.width, canvas.height);
            if (bgX < 0) ctx.drawImage(bgImg, bgX + canvas.width, 0, canvas.width, canvas.height);
        } else ctx.drawImage(bgImg, 0, 0, canvas.width, canvas.height);
        bgDrawn = true;
    }
    if (!bgDrawn) {
        if(levelData.indoors) { let grad = ctx.createLinearGradient(0, 0, 0, canvas.height); grad.addColorStop(0, '#2a1a15'); grad.addColorStop(1, '#4e342e'); ctx.fillStyle = grad; } 
        else { let grad = ctx.createLinearGradient(0, 0, 0, canvas.height); grad.addColorStop(0, '#0f0f1a'); grad.addColorStop(1, '#2b3a42'); ctx.fillStyle = grad; }
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    ctx.save();
    ctx.translate(-camera.x, 0); 
    
    // Draw Platforms
    levelData.platforms.forEach(plat => { 
        let texture = levelData.indoors ? platformImgs.wood : platformImgs.grass;
        if(isImgLoaded(texture)) {
            let tileW = texture.width; let tileH = texture.height;
            for(let tx = 0; tx < plat.w; tx += tileW) {
                let dw = Math.min(tileW, plat.w - tx);
                ctx.drawImage(texture, 0, 0, dw, tileH, plat.x + tx, plat.y, dw, tileH);
            }
            if (plat.h > tileH) { ctx.fillStyle = levelData.indoors ? '#3e2723' : '#5d4037'; ctx.fillRect(plat.x, plat.y + tileH, plat.w, plat.h - tileH); }
        } else {
            ctx.fillStyle = levelData.indoors ? '#3e2723' : '#5d4037'; ctx.fillRect(plat.x, plat.y, plat.w, plat.h); 
        }
    });

    levelData.items.forEach(item => {
        if(item.collected) return;
        if(item.type === 'mushroom') { if(isImgLoaded(itemImgs.mushroom)) ctx.drawImage(itemImgs.mushroom, item.x, item.y, item.w, item.h); else drawEmoji('ğŸ„', item.x, item.y + 30, 60); }
        else if(item.type === 'chest') { let img = item.opened ? itemImgs.chest_open : itemImgs.chest_closed; if(isImgLoaded(img)) ctx.drawImage(img, item.x, item.y, item.w, item.h); else { let icon = item.opened ? 'ğŸ' : 'ğŸ“¦'; drawEmoji(icon, item.x, item.y + 35, 40); } }
        else if(item.type === 'fruit') { if(isImgLoaded(itemImgs.fruit)) ctx.drawImage(itemImgs.fruit, item.x, item.y, item.w, item.h); else drawEmoji('ğŸ', item.x, item.y + 20, 40); }
        else if(item.type === 'bucket') { if(isImgLoaded(itemImgs.bucket)) ctx.drawImage(itemImgs.bucket, item.x, item.y, item.w, item.h); else drawEmoji('ğŸª£', item.x, item.y + 25, 40); }
        else if(item.type === 'door') { 
            // ğŸšª é–€çš„å‹•ç•«ç¹ªè£½
            if (itemImgs.door_sheet && isImgLoaded(itemImgs.door_sheet)) {
                 let totalFrames = 8;
                 let frameW = itemImgs.door_sheet.width / totalFrames;
                 let frameH = itemImgs.door_sheet.height;
                 let currentFrame = 0;
                 if (item.open) { currentFrame = Math.floor(Date.now() / 150) % totalFrames; }
                 ctx.drawImage(itemImgs.door_sheet, currentFrame * frameW, 0, frameW, frameH, item.x, item.y, item.w, item.h);
            } else {
                let img = item.open ? itemImgs.door_open : itemImgs.door_closed; 
                if(isImgLoaded(img)) ctx.drawImage(img, item.x, item.y, item.w, item.h); 
                else { 
                    ctx.fillStyle = item.open ? '#000' : '#4e342e'; ctx.fillRect(item.x, item.y, item.w, item.h); 
                    ctx.strokeStyle = '#6d4c41'; ctx.lineWidth = 4; ctx.strokeRect(item.x, item.y, item.w, item.h); 
                    if(!item.open) { ctx.fillStyle = '#ffd700'; ctx.beginPath(); ctx.arc(item.x+item.w-20, item.y+item.h/2, 5, 0, Math.PI*2); ctx.fill(); } 
                }
            }
        }
    });

    if(levelData.waves) {
        ctx.strokeStyle = '#81d4fa'; ctx.lineWidth = 4;
        levelData.waves.forEach(w => { ctx.beginPath(); ctx.arc(w.x + 15, w.y + 25, 15, Math.PI/2, -Math.PI/2, false); ctx.stroke(); ctx.beginPath(); ctx.arc(w.x + 25, w.y + 25, 30, Math.PI/2, -Math.PI/2, false); ctx.stroke(); });
    }

    // Sprite drawing helper
    function drawSprite(ctx, img, x, y, w, h, frames, speed) {
        let frameW = img.width / frames;
        let frameH = img.height;
        let currentFrame = Math.floor(Date.now() / speed) % frames;
        ctx.drawImage(img, currentFrame * frameW, 0, frameW, frameH, x, y, w, h);
    }

    levelData.npcs.forEach(npc => {
        let sheet = null;
        let img = null;
        
        let frameCount = 4; // é»˜èª

        if(npc.type === 'white_cat') { sheet = charImgs.white_cat_sheet; img = charImgs.white_cat; frameCount = 6; }
        else if(npc.type === 'black_cat') { sheet = charImgs.black_cat_sheet; img = charImgs.black_cat; frameCount = 6; }
        else if(npc.type === 'orange_cat') { sheet = charImgs.orange_cat_sheet; img = charImgs.orange_cat; frameCount = 6; }
        else if(npc.type === 'witch') { sheet = charImgs.witch_sheet; img = charImgs.witch; frameCount = 4; }

        if (sheet && isImgLoaded(sheet)) {
             drawSprite(ctx, sheet, npc.x, npc.y, npc.w, npc.h, frameCount, 200); 
        } 
        else if (img && isImgLoaded(img)) {
            ctx.drawImage(img, npc.x, npc.y, npc.w, npc.h);
        }
        else {
            if(npc.type === 'white_cat') drawEmoji('ğŸ±', npc.x, npc.y + npc.h/2 + 10, npc.w);
            else if(npc.type === 'black_cat') { ctx.save(); ctx.translate(npc.x + npc.w/2, npc.y + npc.h/2); if(npc.alert) ctx.scale(5, 5); drawEmoji('ğŸˆâ€â¬›', -15, 15, 30); ctx.restore(); }
            else if(npc.type === 'orange_cat') { drawEmoji('ğŸˆ', npc.x, npc.y + npc.h/2 + 10, npc.w); if(npc.scared) drawEmoji('ğŸ’¨', npc.x-30, npc.y + 20, 50); }
            else if(npc.type === 'witch') { drawEmoji('ğŸ§™â€â™€ï¸', npc.x, npc.y + 70, 80); if(!player.inventory.knowsSecret) drawEmoji('ğŸ“–', npc.x - 20, npc.y + 40, 30); drawEmoji('ğŸ’§', npc.x + 10, npc.y + 20, 30); }
        }
    });

    drawPlayer(ctx, player);
    ctx.restore();
    drawUI(); 
    if (currentState === GAME_STATE.INVENTORY) drawInventory(); 
    else if (currentState === GAME_STATE.GOT_ITEM) drawItemPopup();
    else if (currentState === GAME_STATE.HISTORY) drawHistory();

    let grad = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 200, canvas.width/2, canvas.height/2, 500);
    grad.addColorStop(0, 'rgba(0,0,0,0)'); grad.addColorStop(1, 'rgba(0,0,0,0.6)'); ctx.fillStyle = grad; ctx.fillRect(0, 0, canvas.width, canvas.height);

    if(!levelData.indoors && currentState !== GAME_STATE.ENDING_SEQUENCE) {
        ctx.strokeStyle = 'rgba(174, 194, 224, 0.4)'; ctx.lineWidth = 1; ctx.beginPath();
        rainDrops.forEach(drop => { ctx.moveTo(drop.x, drop.y); ctx.lineTo(drop.x, drop.y + drop.length); }); ctx.stroke();
        ctx.save(); ctx.translate(-camera.x, 0); ctx.fillStyle = 'rgba(200, 220, 255, 0.6)';
        particles.forEach(p => ctx.fillRect(p.x, p.y, 2, 2)); ctx.restore();
    }
}

function drawUI() { for (let i = 0; i < player.maxHp; i++) { let x = 20 + i * 35; let y = 30; if (i < player.hp) drawEmoji('â¤ï¸', x, y, 24); else drawEmoji('ğŸ–¤', x, y, 24); } if (player.invisible) { let seconds = Math.ceil(player.invisibleTimer / 60); ctx.fillStyle = '#90ee90'; ctx.font = '12px "Press Start 2P"'; ctx.textAlign = 'left'; ctx.fillText(`ğŸ‘» INVIS: ${seconds}s`, 20, 60); } }
function drawInventory() { ctx.fillStyle = 'rgba(0, 0, 0, 0.8)'; ctx.fillRect(0, 0, canvas.width, canvas.height); const boxW = 400; const boxH = 300; const boxX = (canvas.width - boxW) / 2; const boxY = (canvas.height - boxH) / 2; ctx.strokeStyle = '#fff'; ctx.lineWidth = 4; ctx.strokeRect(boxX, boxY, boxW, boxH); ctx.fillStyle = '#222'; ctx.fillRect(boxX, boxY, boxW, boxH); ctx.fillStyle = '#ffcc00'; ctx.font = '20px "Press Start 2P"'; ctx.textAlign = 'center'; ctx.fillText("INVENTORY", canvas.width / 2, boxY + 50); ctx.font = '14px "Press Start 2P"'; ctx.fillStyle = '#fff'; ctx.textAlign = 'left'; let startY = boxY + 100; let gap = 40; let itemCount = 0; function drawIcon(img, x, y) { if(isImgLoaded(img)) ctx.drawImage(img, x, y - 20, 24, 24); else return false; return true; } if (player.inventory.hasKey) { if(!drawIcon(iconImgs.key, boxX + 60, startY + itemCount * gap)) drawEmoji('ğŸ”‘', boxX + 60, startY + itemCount * gap, 24); ctx.fillText("Cabin Key", boxX + 100, startY + itemCount * gap); itemCount++; } if (player.inventory.hasFish) { if(!drawIcon(iconImgs.fish, boxX + 60, startY + itemCount * gap)) drawEmoji('ğŸŸ', boxX + 60, startY + itemCount * gap, 24); ctx.fillText("Phantom Fish", boxX + 100, startY + itemCount * gap); itemCount++; } if (player.inventory.hasSwatter) { if(!drawIcon(iconImgs.swatter, boxX + 60, startY + itemCount * gap)) drawEmoji('ğŸ¸', boxX + 60, startY + itemCount * gap, 24); ctx.fillText("Elec. Swatter", boxX + 100, startY + itemCount * gap); itemCount++; } if (player.inventory.hasFruit) { if(!drawIcon(iconImgs.fruit, boxX + 60, startY + itemCount * gap)) drawEmoji('ğŸ', boxX + 60, startY + itemCount * gap, 24); ctx.fillText("Invisible Fruit", boxX + 100, startY + itemCount * gap); itemCount++; } if (itemCount === 0) { ctx.fillStyle = '#888'; ctx.textAlign = 'center'; ctx.fillText("Empty...", canvas.width / 2, boxY + 150); } ctx.font = '10px "Press Start 2P"'; ctx.fillStyle = '#aaa'; ctx.textAlign = 'center'; ctx.fillText("Press 'I' to Close", canvas.width / 2, boxY + boxH - 20); }
function drawHistory() { ctx.fillStyle = 'rgba(0, 0, 0, 0.9)'; ctx.fillRect(0, 0, canvas.width, canvas.height); const boxW = 600; const boxH = 380; const boxX = (canvas.width - boxW) / 2; const boxY = (canvas.height - boxH) / 2; ctx.strokeStyle = '#888'; ctx.lineWidth = 2; ctx.strokeRect(boxX, boxY, boxW, boxH); ctx.fillStyle = '#ffcc00'; ctx.font = '18px "Press Start 2P"'; ctx.textAlign = 'center'; ctx.fillText("CHAT LOG", canvas.width / 2, boxY + 40); ctx.font = '10px "Press Start 2P"'; ctx.textAlign = 'left'; ctx.fillStyle = '#fff'; let startY = boxY + 80; let recentLogs = dialogueHistory.slice(-12); for (let i = 0; i < recentLogs.length; i++) { let text = recentLogs[i]; if (text.length > 60) text = text.substring(0, 58) + "..."; ctx.fillText("> " + text, boxX + 30, startY + i * 25); } ctx.font = '10px "Press Start 2P"'; ctx.fillStyle = '#aaa'; ctx.textAlign = 'center'; ctx.fillText("Press 'H' to Close", canvas.width / 2, boxY + boxH - 20); }
function drawItemPopup() { ctx.fillStyle = 'rgba(0, 0, 0, 0.8)'; ctx.fillRect(0, 0, canvas.width, canvas.height); const boxW = 500; const boxH = 250; const boxX = (canvas.width - boxW) / 2; const boxY = (canvas.height - boxH) / 2; ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 4; ctx.strokeRect(boxX, boxY, boxW, boxH); let grad = ctx.createLinearGradient(boxX, boxY, boxX, boxY + boxH); grad.addColorStop(0, '#444'); grad.addColorStop(1, '#111'); ctx.fillStyle = grad; ctx.fillRect(boxX, boxY, boxW, boxH); ctx.fillStyle = '#ffcc00'; ctx.font = '16px "Press Start 2P"'; ctx.textAlign = 'center'; ctx.fillText("YOU GOT!", canvas.width / 2, boxY + 40); if (popupData.img && isImgLoaded(popupData.img)) { ctx.drawImage(popupData.img, canvas.width / 2 - 20, boxY + 80, 40, 40); } else { drawEmoji(popupData.icon, canvas.width / 2 - 20, boxY + 100, 40); } ctx.fillStyle = '#fff'; ctx.font = '12px "Press Start 2P"'; ctx.fillText(popupData.text, canvas.width / 2, boxY + 140); ctx.fillStyle = '#ccc'; ctx.font = '10px "Press Start 2P"'; if(popupData.desc) { let words = popupData.desc.split(' '); let line = ''; let lineHeight = 20; let y = boxY + 170; for(let n = 0; n < words.length; n++) { let testLine = line + words[n] + ' '; let metrics = ctx.measureText(testLine); let testWidth = metrics.width; if (testWidth > boxW - 40 && n > 0) { ctx.fillText(line, canvas.width / 2, y); line = words[n] + ' '; y += lineHeight; } else { line = testLine; } } ctx.fillText(line, canvas.width / 2, y); } ctx.fillStyle = '#888'; ctx.font = '8px "Press Start 2P"'; if (Math.floor(Date.now() / 500) % 2 === 0) ctx.fillText("PRESS 'F' TO CONTINUE", canvas.width / 2, boxY + boxH - 20); }
function drawEnding() { let bgDrawn = false; let bgImg = bgImgs.ending; if (bgImg && isImgLoaded(bgImg)) { ctx.drawImage(bgImg, 0, 0, canvas.width, canvas.height); bgDrawn = true; } if (!bgDrawn) { let grad = ctx.createLinearGradient(0, 0, 0, canvas.height); grad.addColorStop(0, '#4fc3f7'); grad.addColorStop(1, '#e1f5fe'); ctx.fillStyle = grad; ctx.fillRect(0, 0, canvas.width, canvas.height); drawEmoji('â˜€ï¸', 100, 80, 80); ctx.fillStyle = '#66bb6a'; ctx.fillRect(0, 380, canvas.width, 70); ctx.fillStyle = '#81c784'; ctx.fillRect(0, 380, canvas.width, 10); } ctx.fillStyle = '#333'; ctx.font = '24px "Press Start 2P"'; ctx.textAlign = 'center'; ctx.shadowColor="white"; ctx.shadowBlur=0; ctx.fillText("Happily Ever After", canvas.width/2, 200); ctx.font = '16px "Press Start 2P"'; ctx.fillText("THE END", canvas.width/2, 250); }
function drawPlayer(ctx, player) { ctx.save(); if(player.iframes > 0 && Math.floor(Date.now() / 100) % 2 === 0) ctx.globalAlpha = 0.5; else ctx.globalAlpha = player.invisible ? 0.4 : 1.0; let currentImg = charImgs.player; if (isImgLoaded(charImgs.player_idle1)) { if (player.state === 'run') { if (Math.floor(Date.now() / 150) % 2 === 0 && isImgLoaded(charImgs.player_run1)) currentImg = charImgs.player_run1; else if (isImgLoaded(charImgs.player_run2)) currentImg = charImgs.player_run2; else if (isImgLoaded(charImgs.player_run1)) currentImg = charImgs.player_run1; } else if (player.state === 'jump' && isImgLoaded(charImgs.player_jump)) { currentImg = charImgs.player_jump; } else if (player.state === 'idle') { if (Math.floor(Date.now() / 500) % 2 === 0) currentImg = charImgs.player_idle1; else if (isImgLoaded(charImgs.player_idle2)) currentImg = charImgs.player_idle2; } } if(isImgLoaded(currentImg)) { if(!player.facingRight) { ctx.translate(player.x + player.width, player.y); ctx.scale(-1, 1); ctx.drawImage(currentImg, 0, 0, player.width, player.height); } else { ctx.drawImage(currentImg, player.x, player.y, player.width, player.height); } } else if(player.customEmoji !== '') { if(!player.facingRight) { ctx.translate(player.x + player.width, player.y); ctx.scale(-1, 1); ctx.font = '50px Arial'; ctx.fillText(player.customEmoji, 0, 30); } else { ctx.font = '50px Arial'; ctx.fillText(player.customEmoji, player.x - 4, player.y + 28); } } else { ctx.fillStyle = player.color; ctx.fillRect(player.x, player.y, player.width, player.height); ctx.fillStyle = '#fff'; if(player.facingRight) ctx.fillRect(player.x + 14, player.y + 6, 4, 4); else ctx.fillRect(player.x + 4, player.y + 6, 4, 4); } ctx.restore(); }
function drawEmoji(emoji, x, y, size=24) { ctx.font = `${size}px Arial`; ctx.fillText(emoji, x, y); }
function loop() { update(); draw(); requestAnimationFrame(loop); }

init();

</script>
</body>
</html>
